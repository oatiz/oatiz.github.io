{"meta":{"title":"oatiz 的博客","subtitle":"JAVA | JVM | DSAA","description":"迷途的羔羊","author":"oatiz","url":"https://oatiz.me"},"pages":[{"title":"About","date":"2018-06-08T10:41:07.826Z","updated":"2018-06-08T10:41:07.826Z","comments":true,"path":"about/index.html","permalink":"https://oatiz.me/about/index.html","excerpt":"","text":"友情链接宇宙湾 大数据大佬 Syoko 女装大佬"},{"title":"Project","date":"2018-06-08T10:41:07.826Z","updated":"2018-06-08T10:41:07.826Z","comments":true,"path":"project/index.html","permalink":"https://oatiz.me/project/index.html","excerpt":"","text":""},{"title":"Tags","date":"2018-06-08T10:41:07.826Z","updated":"2018-06-08T10:41:07.826Z","comments":true,"path":"tags/index.html","permalink":"https://oatiz.me/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"skywalking5.0部署搭建","slug":"skywalking5-0-0-beta-deployment-build","date":"2018-05-15T10:41:45.000Z","updated":"2018-06-08T10:41:07.826Z","comments":true,"path":"2018/05/15/skywalking5-0-0-beta-deployment-build/","link":"","permalink":"https://oatiz.me/2018/05/15/skywalking5-0-0-beta-deployment-build/","excerpt":"","text":"介绍skywalking官网 skywalking-github 背景基于之前我用过zipkin与pinpoint,可以做下简单的对比(基于我自己的理解): 部署简易度(由低到高) \b\bzipkin –&gt; skywalking –&gt; pinpoint 性能方面(由低到高) pinpoint –&gt; zipnkin –&gt; skywaling 相关文章:几种分布式调用链监控组件的实践与比较 我们生产使用的spring cloud体系, \beureka来做服务发现,feign进行通信,默认使用 hystrix做服务熔断. 结合上述相关介绍,我们最终采用skywalking 部署下载点击下载地址,然后选择对应版本进行下载,解压 解压下载后解压,文件目录可以分为三部分: agent: 需要监控的应用的代理 collector: 应用trace信息收集器(被监控应用内数据会被收集起来) webapp: 前端页面展示 结构如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657apache-skywalking-apm-incubating|-- agent| |-- activations| | |-- apm-toolkit-log4j-1.x-activation-5.0.0-beta-SNAPSHOT.jar| | |-- apm-toolkit-log4j-2.x-activation-5.0.0-beta-SNAPSHOT.jar| | |-- apm-toolkit-logback-1.x-activation-5.0.0-beta-SNAPSHOT.jar| | |-- apm-toolkit-opentracing-activation-5.0.0-beta-SNAPSHOT.jar| | `-- apm-toolkit-trace-activation-5.0.0-beta-SNAPSHOT.jar| |-- config| | `-- agent.config| |-- logs| |-- optional-plugins| | `-- apm-spring-annotation-plugin-5.0.0-beta-SNAPSHOT.jar| |-- plugins| | |-- apm-dubbo-plugin-5.0.0-beta-SNAPSHOT.jar| | |-- apm-elastic-job-2.x-plugin-5.0.0-beta-SNAPSHOT.jar| | |-- ......| | `-- tomcat-7.x-8.x-plugin-5.0.0-beta-SNAPSHOT.jar| `-- skywalking-agent.jar|-- bin| |-- collectorService.bat| |-- collectorService.sh| |-- startup.bat| |-- startup.sh| |-- webappService.bat| `-- webappService.sh|-- collector-libs| |-- agent-grpc-define-5.0.0-beta-SNAPSHOT.jar| |-- agent-grpc-provider-5.0.0-beta-SNAPSHOT.jar| |-- agent-jetty-define-5.0.0-beta-SNAPSHOT.jar| |-- ......| `-- zookeeper-3.4.10.jar|-- config| |-- application.yml| |-- component-libraries.yml| `-- log4j2.xml|-- DISCLAIMER|-- LICENSE|-- licenses| |-- LICENSE-annotations.txt| |-- LICENSE-antlr4-runtime.txt| |-- ......| |-- LICENSE-zuul.txt| `-- ui-licenses| |-- LICENSE-add-dom-event-listener| |-- LICENSE-antd| |-- ......| `-- LICENSE-whatwg-fetch|-- logs| |-- collector.log| |-- skywalking-collector-server.log| |-- webapp-console.log| `-- webapp.log|-- NOTICE|-- README.txt`-- webapp `-- skywalking-webapp.jar \b后端部署 修改config/application.yml,将里面所有host改为物理机ip 修改bin/webappService.sh,将collector.ribbon.listOfServers=127.0.0.1:10800,改为config/application.yml里面naming.jetty.host与port 执行bin/startup.sh 需要注意的是,skywalking数据采用elasticsearch 存储.需要部署es,并且修改es的配置文件 elasticsearch.yml,将对应配置改为\b以下配置: 12network.host: 0.0.0.0thread_pool.bulk.queue_size: 1000 agent部署 复制skywalking-agent到任意目录 配置agent/config/agent.config文件 将collector.servers填写为collector配置文件(config/application.yml)中naming/jetty/ip:port 添加参数 在jvm启动参数添加:-javaagent:/path/to/skywalking-agent/skywalking-agent.jar 假设我们已经将skywalking-agent放到/opt/skywalking/目录下,那么我们的启动命令应该写为: java -javaagent:/opt/skywalking/agent/skywalking-agent.jar -Dskywalking.agent.application_code=gateway -jar gateway.jar 配置除了通过/config/agent.config文件外,可以通过环境变量和VM参数(-D)来进行设置 其他因为现有版本5.0.0-alpha有bug,所以需要使用新发布的5.0.0-beta版,所以需要编译对应版本源码 拉取skywalking对应版本代码 git clone https://github.com/apache/incubator-skywalking.git git checkout v5.0.0-beta 拉取子模块 git submodule init git submodule update 修改npm源 打开apm-webapp/pom.xml,搜索frontend-maven-plugin 将install --registry=https://registry.npmjs.org/ 替换为 install --registry=https://registry.npm.taobao.org/ 编译 mvn clean package -DskipTests 打包成功后对应的skywalking存放在apm-dist/target目录下,根据上面的部署步骤使用 注意事项 ES版本问题:5.3.x有问题,请使用5.5.x或5.6.x \bagent中的collector.ip需要与collector 中配置文件中的相同(agent与collector在不同机器时,注意将ip改为对应机器的ip) 部署agent,collector机器的系统时区必须一致(\b不同时dashboard中查看不到数据) 编译时替换npm源 参考链接skywalking-中文文档\b","categories":[],"tags":[{"name":"apm","slug":"apm","permalink":"https://oatiz.me/tags/apm/"},{"name":"skywalking","slug":"skywalking","permalink":"https://oatiz.me/tags/skywalking/"}]},{"title":"hexo mermaid","slug":"mermaid-test","date":"2017-12-04T16:25:06.000Z","updated":"2018-06-08T10:41:07.826Z","comments":true,"path":"2017/12/04/mermaid-test/","link":"","permalink":"https://oatiz.me/2017/12/04/mermaid-test/","excerpt":"","text":"mermaidflowchartgraph TD A-->B; A-->C; B-->D; C-->D; sequencesequenceDiagram participant Alice participant Bob Alice->>John: Hello John, how are you? loop Healthcheck John->>John: Fight against hypochondria end Note right of John: Rational thoughts prevail... John-->>Alice: Great! John->>Bob: How about you? Bob-->>John: Jolly good! ganttgantt dateFormat YYYY-MM-DD title Adding GANTT diagram to mermaid section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d git graphgitGraph: options { \"nodeSpacing\": 150, \"nodeRadius\": 10 } end commit branch newbranch checkout newbranch commit commit checkout master commit commit merge newbranch code1echo \"HelloWorld\" 12345678910@requires_authorizationdef somefunc(param1='', param2=0): r'''A docstring''' # interesting if param1 &gt; param2: print 'Gre\\'ater' return (param2 - param1 + 1) or Noneclass SomeClass: pass","categories":[],"tags":[{"name":"mermaid","slug":"mermaid","permalink":"https://oatiz.me/tags/mermaid/"}]},{"title":"GC学习笔记:GC标记-清除算法(三)","slug":"GC-notes-3-GC-mark-clear-algorithm","date":"2017-11-26T00:17:52.000Z","updated":"2018-06-08T10:41:07.826Z","comments":true,"path":"2017/11/26/GC-notes-3-GC-mark-clear-algorithm/","link":"","permalink":"https://oatiz.me/2017/11/26/GC-notes-3-GC-mark-clear-algorithm/","excerpt":"","text":"GC标记-清除算法标记阶段清除阶段分配合并优点实现简单与保守式GC兼容缺点碎片化分配速度与写时复制技术不兼容多个空闲链表BiBOP算法位图标记优点与写时复制技术兼容清除操作更高效延迟清除法","categories":[],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://oatiz.me/tags/JVM/"},{"name":"GC","slug":"GC","permalink":"https://oatiz.me/tags/GC/"},{"name":"DASS","slug":"DASS","permalink":"https://oatiz.me/tags/DASS/"}]},{"title":"GC学习笔记:GC相关知识(二)","slug":"GC-notes-2-GC-related-knowledge","date":"2017-11-26T00:16:23.000Z","updated":"2018-06-08T10:41:07.826Z","comments":true,"path":"2017/11/26/GC-notes-2-GC-related-knowledge/","link":"","permalink":"https://oatiz.me/2017/11/26/GC-notes-2-GC-related-knowledge/","excerpt":"","text":"GC中基本概念对象/头/域对象\b在GC里,对象表示”通过应用程序利用的数据的集合”。对象配置在内存空间中,GC会根据情况将配置好的对象进行移动或销毁操作。因此,对象是GC的基本单位。对象由“头(header)”与“域(field)”组成 头将对象中保存对象本身信息的部分称为“头”,主要包括以下信息: GC运行所需信息(预先存有) 对象的大小 对象的种类 域把对象使用者在对象中可访问的部分称为“域”,域中的数据类型大致分为2种: 指针\b指向内存空间中某块区域的值 非指针\b编程中直接使用值本身 mutatormutator有改变某物的意思,即改变GC对象间的引用关系。它的实体即为“应用程序”,它进行的实际操作分为2种: 生成对象 更新指针 mutator在进行这些操作是,会为应用程序的用户进行一些处理,随着这些处理的推进,对象间的引用关系随之也会发生”改变”,伴随着这些变化会产生垃圾,而负责\b会后这些就是GC 堆堆是用于存放对象的内存空间,在java堆的实现是一种特殊的树型数据结构 活动对象/非活动对象在已分配到堆中的对象,那些能通过\b程序引用的对象称为”活动对象”,反之,不能通过引用的对象称为”非活动对象”,也就是GC需要回收掉的部分 分配分配(allocation)指的是在内存空间分配对象。当\b堆被活动对象占满,运行GC也无法配置可用空间时,有以下两种选择: 销毁所有计算结果,输出错误信息 扩大堆,分配可用空间 分块分块(chunk)在GC世界里指的是为利用对象而事先准备出来的空间。初始情况下,堆被一个大的分块占据,然后根据mutator的要求把这个分块分割成合适的大小,作为(活动)对象使用。活动对象不久会转化为垃圾回收,此时这部分被回收的内存空间再次分为分块,为下次被利用做准备。周而复始… graph LR A[分块] --> B(活动对象) B --> C{非活动对象} C -->A 根根是指向对象的指针的“起点部分”。 在Java中,可作为根的主要在全局性的引用(例如常量或类静态属性)与执行上下文(例如栈帧中的本地变量表)中。 评价标准评价GC算法性能时,采用以下4个标准: 吞吐量吞吐量指的是单位时间内的处理能力,大概为\bHEAP_SIZE／(GC TIME) 最大暂停时间因执行GC而暂停执行mutator的最长时间, 如mutator执行过程中,共GC了3次,分别耗时1s,5s,3s那么最大暂停时间为5s 堆使用效率 访问的局限性具有引用关系的对象之间通常很可能存在连续访问的情况称为“访问的局限性”。一般会把数据存放到内存中,当cpu访问数据时,仅把要使用的数据从内存中读取到缓存。与此同时,我们还将它附件的所有数据都读取到缓存中\b,从而压缩读取数据所需要的时间。考虑到访问的局限性,把具有引用关系的对象安排到堆中相近的位置,就能提高在缓存中读取到想利用数据的概率。","categories":[],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://oatiz.me/tags/JVM/"},{"name":"GC","slug":"GC","permalink":"https://oatiz.me/tags/GC/"},{"name":"DASS","slug":"DASS","permalink":"https://oatiz.me/tags/DASS/"}]},{"title":"GC学习笔记:GC定义及历史(一)","slug":"GC-notes-1-GC-history","date":"2017-11-25T23:11:14.000Z","updated":"2018-06-08T10:41:07.826Z","comments":true,"path":"2017/11/25/GC-notes-1-GC-history/","link":"","permalink":"https://oatiz.me/2017/11/25/GC-notes-1-GC-history/","excerpt":"","text":"前言\b\b 现实开发中,业务开发人员其实很少接触到GC相关的工作,本人接触GC纯粹是因为好奇和R大的早期博文与一些论坛的回答。断断续续的接触一些碎片化的知识,\b借此将其写下来作为自己学习的一个论证吧。 此系列是阅读中村成洋与相川光著的垃圾回收的算法与实现的笔记。\b 定义GC是Garbage Collection的缩写,也就是“垃圾回收”。顾名思义,程序的垃圾回收就是把程序不用的内存空间回收。 \b\b做的事情 找到内存空间的垃圾 回收垃圾,让空间再次得以利用 \bGC的好处没有GC的\b世界里,由程序员自己手动进行内存管理,这势必非常地麻烦。可能会发生如下问题: 忘记释放内存空间会发生内存泄漏问题 \b释放空间时,忘记初始化指向释放对象的内存空间指针时\b,会发生悬垂指针问题 错误的释放了正在使用中的内存空间,会使程序发生错误 所以在现在的高级语言中都有GC,避免了程序员手动释放内存的麻烦和可能会出现的安全问题 GC的历史 1959: D. Edwards实现了GC 1960: John McCarthy发布了初代GC算法即标记-清除算法 1960: George E. Collins发布了引用计数算法 1963: Marvin L. Minsky发布了复制算法 1996: 首次出版了Garbage Collection一书","categories":[],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://oatiz.me/tags/JVM/"},{"name":"GC","slug":"GC","permalink":"https://oatiz.me/tags/GC/"}]},{"title":"建站前言","slug":"preface","date":"2017-07-28T00:24:25.000Z","updated":"2018-06-08T10:41:07.826Z","comments":true,"path":"2017/07/28/preface/","link":"","permalink":"https://oatiz.me/2017/07/28/preface/","excerpt":"","text":"组件hexoyilia tips 评论采用Disqus,需翻墙后才可留言 碎碎念其实在建站之前已经有过一个blog了,但是没有保持下去。原因个人觉得别人已经写好了,没必要重复的去抄别人:)。现在重新得去编写,其实觉得现在的生活乏味无趣,不如找个事情来充实自己。再者自己基础知识很不好,借着这个名头坚持下。 说到学习笔记,个人会通过看书,读别人的博客,实践来验证自己所需掌握的知识点。在此站,会将各个出处标识清楚。 碎碎念结束,愿自己坚持下去。 祝好:)","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://oatiz.me/tags/随笔/"}]}]}