{"meta":{"title":"oatiz 的博客","subtitle":"JAVA | JVM | DSAA","description":"迷途的羔羊","author":"oatiz","url":"https://oatiz.me"},"pages":[{"title":"About","date":"2018-11-29T11:57:04.674Z","updated":"2018-11-29T11:57:04.674Z","comments":true,"path":"about/index.html","permalink":"https://oatiz.me/about/index.html","excerpt":"","text":"友情链接宇宙湾 大数据大佬 Syoko 女装大佬"},{"title":"Project","date":"2018-11-29T11:57:04.678Z","updated":"2018-11-29T11:57:04.678Z","comments":true,"path":"project/index.html","permalink":"https://oatiz.me/project/index.html","excerpt":"","text":""},{"title":"Tags","date":"2018-11-29T11:57:04.678Z","updated":"2018-11-29T11:57:04.678Z","comments":true,"path":"tags/index.html","permalink":"https://oatiz.me/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"rust中所有权,引用,生命周期小记","slug":"rust_ownership","date":"2018-11-29T16:13:04.000Z","updated":"2018-11-29T11:57:04.674Z","comments":true,"path":"2018/11/29/rust_ownership/","link":"","permalink":"https://oatiz.me/2018/11/29/rust_ownership/","excerpt":"","text":"rust 所有权,引用,生命周期所有权存在即是为了管理堆数据 跟踪代码正在堆上使用的数据 最大限度减少堆上的重复数据 清理堆上不再使用的数据 rules Each value in Rust has a variable that’s called its owner. rust每个值都有一个被叫做owner的变量 There can only be one owner at a time. 值只能有一个所有者 When the owner goes out of scope, the value will be dropped. 当所有者离开作用域,值将会被清除 RAIIResource Acquisition Is Initialization (RAII) 引用与借用引用作为方法函数为借用, 脱离作用域值不会被丢弃掉 数据竞争(data race)数据竞争先决条件: Two or more pointers access the same data at the same time. 两个或多个指针同时访问同一数据 At least one of the pointers is being used to write to the data. 至少有一个指针被用来写入数据 There’s no mechanism being used to synchronize access to the data. 没有同步数据访问的机制 rules At any given time, you can have either one mutable reference or any number of immutable references. 任意给定时间,只能拥有一个可变引用或者多个不可变引用 References must always be valid. 引用必须总是有效的 生命周期用来解决悬垂指针问题悬垂指针(dangling pointer): 指针指向的内存已经被分配给其他自由者 TODO …","categories":[],"tags":[{"name":"rust","slug":"rust","permalink":"https://oatiz.me/tags/rust/"},{"name":"ownership","slug":"ownership","permalink":"https://oatiz.me/tags/ownership/"},{"name":"lifetime","slug":"lifetime","permalink":"https://oatiz.me/tags/lifetime/"},{"name":"RAII","slug":"RAII","permalink":"https://oatiz.me/tags/RAII/"}]},{"title":"JVM常量池小解","slug":"The_Constant_Pool","date":"2018-10-16T21:40:00.000Z","updated":"2018-11-29T11:57:04.674Z","comments":true,"path":"2018/10/16/The_Constant_Pool/","link":"","permalink":"https://oatiz.me/2018/10/16/The_Constant_Pool/","excerpt":"","text":"前言今日,同事问我一个问题,以下java代码输出什么:123String s1 = \"hello world\";String s2 = \"hello\" + \" \" + \"world\";System.out.println(s1 == s2); //true 沉思了一下,依我的编码经验给出了结果为true,辣么他接着问这是为什么,于是乎我就说常量是在编译期间存放在常量池中的,他接着问什么是常量池,都有什么东西存放在里面? 综上所述,引出了今天我们的问题什么是常量池? 定义Run-Time Constant Pool A run-time constant pool is a per-class or per-interface run-time representation of the constant_pool table in a class file. It contains several kinds of constants, ranging from numeric literals known at compile-time to method and field references that must be resolved at run-time. The run-time constant pool serves a function similar to that of a symbol table for a conventional programming language, although it contains a wider range of data than a typical symbol table. 运行时常量池(Runtime Constant Pool)是每一个类或接口的常量池(Constant_Pool)的运行时表示形式,它包括了若干种不同的常量:从编译期可知的数值字面量到必须运行 期解析后才能获得的方法或字段引用。运行时常量池扮演了类似传统语言中符号表(Symbol Table)的角色，不过它存储数据范围比通常意义上的符号表要更为广泛。 The Constant Pool Java Virtual Machine instructions do not rely on the run-time layout of classes, interfaces, class instances, or arrays. Instead, instructions refer to symbolic information in the constant_pool table. Java 虚拟机指令执行时不依赖与类、接口,实例或数组的运行时布局,而是依赖常量池(constant_pool)表中的符号信息 以上是jvm规范中定义的,简单点来说:在程序运行期间有块区域叫运行时常量池,运行时常量池里面存储着一些常量池结构的数据(每个结构里面都是class文件中的某种类型的字面量) 结构1234cp_info &#123; u1 tag; u1 info[];&#125; jvm规定了不同的tag值和不同类型的字面量对应关系,如下图所示: Constant Type Value CONSTANT_Class 7 CONSTANT_Fieldref 9 CONSTANT_Methodref 10 CONSTANT_InterfaceMethodref 11 CONSTANT_String 8 CONSTANT_Integer 3 CONSTANT_Float 4 CONSTANT_Long 5 CONSTANT_Double 6 CONSTANT_NameAndType 12 CONSTANT_Utf8 1 CONSTANT_MethodHandle 15 CONSTANT_MethodType 16 CONSTANT_InvokeDynamic 18 此次只分析基本类型与String: CONSTANT_String_info1234CONSTANT_String_info &#123; u1 tag; u2 string_index;&#125; u1表示1个无符号字节,u2表示2个无符号字节tag: 8string_index: 指向CONSTANT_Utf8_info结构体 CONSTANT_Utf8_info12345CONSTANT_Utf8_info &#123; u1 tag; u2 length; u1 bytes[length];&#125; u1表示1个无符号字节,u2表示2个无符号字节tag: 1length: utf-8编码的字节数组的长度bytes[lenth]: utf-8编码的字节数组 CONSTANT_Integer_info1234CONSTANT_Integer_info &#123; u1 tag; u4 bytes;&#125; u1表示1个无符号字节,u4表示4个无符号字节tag: 3bytes: int常量的值 CONSTANT_Float_info1234CONSTANT_Float_info &#123; u1 tag; u4 bytes;&#125; u1表示1个无符号字节,u4表示4个无符号字节tag: 4bytes: float常量的值 CONSTANT_Long_info12345CONSTANT_Long_info &#123; u1 tag; u4 high_bytes; u4 low_bytes;&#125; u1表示1个无符号字节,u4表示4个无符号字节tag: 5 CONSTANT_Double_info12345CONSTANT_Double_info &#123; u1 tag; u4 high_bytes; u4 low_bytes;&#125; u1表示1个无符号字节,u4表示4个无符号字节tag: 6 bytecode op有人可能就奇怪了,怎么少了byte/short/char/boolean这几个基本类型的呢?jvm在此处有对应的指令支持: \b 类型 范围 指令 \bboolean [0, 1] iconst_n byte [-128, 127] iconst_m1, iconst_n, bipush short [-32768, 32767] iconst_m1, iconst_n, bipush, sipush char [0, 65535] iconst_m1,iconst_n, bipush, sipush, ldc int [-2147483648, 2147483647] iconst_m1, iconst_n, bipush, sipush, ldc byte,short,char其实都是int与boolean类似.也是在编译时就已经变成了int,然后执行int的一些操作符。 测试123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102public static void main(String[] args) &#123; // boolean boolean booltrue = true; boolean boolfalse = false; // byte byte byte_2 = -2; byte byte_1 = -1; // -1是 iconst_m1 byte byte0 = 0; byte byte1 = 1; byte byte2 = 2; byte byte3 = 3; byte byte4 = 4; byte byte5 = 5; byte byte6 = 6; // [0, 5]是 iconst_n 的范围,超出部分用bipush // short short short_2 = -2; short short_1 = -1; short short0 = 0; short short1 = 1; short short2 = 2; short short3 = 3; short short4 = 4; short short5 = 5; short short6 = 6; short short12 = 12; short short127 = 127; short short128 = 128; //从 128开始,超出push的能力,换用sipush short short_32768 = -32768; short short32766 = 32766; short short32767 = 32767; //sipush能表示的范围和 short 一样 // char char char0 = 0; char char1 = 1; char char2 = 2; char char3 = 3; char char4 = 4; char char5 = 5; char char6 = 6; char char12 = 12; char char127 = 127; char char128 = 128; char char32766 = 32766; char char32767 = 32767; char char32768 = 32768; //超出 sipush 能表示的范围, 所以只能用ldc char char65535 = 65535; // int int int_2 = -2; int int_1 = -1; int int0 = 0; int int1 = 1; int int2 = 2; int int3 = 3; int int4 = 4; int int5 = 5; int int6 = 6; int int_129 = -129; int int_128 = -128; int int_127 = -127; int int127 = 127; int int128 = 128; int int255 = 255; int int256 = 256; int int257 = 257; int int_32769 = -32769; int int_32768 = -32768; int int32766 = 32766; int int32767 = 32767; int int32768 = 32768; int int65534 = 65534; int int65535 = 65535; // long (除了0,1 均是ldc(ldc2_w)) long long_2 = -2; long long_1 = -1; long long0 = 0; // lconst_0 long long1 = 1; // lconst_1 long long2 = 2; long long3 = 3; long long4 = 4; long long5 = 5; long long6 = 6; long long_129 = -129; long long_128 = -128; long long_127 = -127; long long127 = 127; long long128 = 128; long long255 = 255; long long256 = 256; long long257 = 257; long long_32769 = -32769; long long_32768 = -32768; long long32766 = 32766; long long32767 = 32767; long long32768 = 32768; long long65534 = 65534; long long65535 = 65535; long long165536 = 165536; &#125; javap结果123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246Classfile /Users/oatiz/IdeaProjects/xxx-daas/daas-test/src/main/java/com/xxx/daas/test/StringTest.class Last modified 2018-10-16; size 1230 bytes MD5 checksum 99b3a33d2192b639186f350eacc0aac2 Compiled from \"StringTest.java\"public class com.xxx.daas.test.StringTest minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_SUPERConstant pool: #1 = Methodref #53.#62 // java/lang/Object.\"&lt;init&gt;\":()V #2 = Integer 32768 #3 = Integer 65535 #4 = Integer -32769 #5 = Integer 65534 #6 = Long -2l #8 = Long -1l #10 = Long 2l #12 = Long 3l #14 = Long 4l #16 = Long 5l #18 = Long 6l #20 = Long -129l #22 = Long -128l #24 = Long -127l #26 = Long 127l #28 = Long 128l #30 = Long 255l #32 = Long 256l #34 = Long 257l #36 = Long -32769l #38 = Long -32768l #40 = Long 32766l #42 = Long 32767l #44 = Long 32768l #46 = Long 65534l #48 = Long 65535l #50 = Long 165536l #52 = Class #63 // com/xxx/daas/test/StringTest #53 = Class #64 // java/lang/Object #54 = Utf8 &lt;init&gt; #55 = Utf8 ()V #56 = Utf8 Code #57 = Utf8 LineNumberTable #58 = Utf8 main #59 = Utf8 ([Ljava/lang/String;)V #60 = Utf8 SourceFile #61 = Utf8 StringTest.java #62 = NameAndType #54:#55 // \"&lt;init&gt;\":()V #63 = Utf8 com/xxx/daas/test/StringTest #64 = Utf8 java/lang/Object&#123; public com.xxx.daas.test.StringTest(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.\"&lt;init&gt;\":()V 4: return LineNumberTable: line 6: 0 public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=2, locals=115, args_size=1 0: iconst_1 1: istore_1 2: iconst_0 3: istore_2 4: bipush -2 6: istore_3 7: iconst_m1 8: istore 4 10: iconst_0 11: istore 5 13: iconst_1 14: istore 6 16: iconst_2 17: istore 7 19: iconst_3 20: istore 8 22: iconst_4 23: istore 9 25: iconst_5 26: istore 10 28: bipush 6 30: istore 11 32: bipush -2 34: istore 12 36: iconst_m1 37: istore 13 39: iconst_0 40: istore 14 42: iconst_1 43: istore 15 45: iconst_2 46: istore 16 48: iconst_3 49: istore 17 51: iconst_4 52: istore 18 54: iconst_5 55: istore 19 57: bipush 6 59: istore 20 61: bipush 12 63: istore 21 65: bipush 127 67: istore 22 69: sipush 128 72: istore 23 74: sipush -32768 77: istore 24 79: sipush 32766 82: istore 25 84: sipush 32767 87: istore 26 89: iconst_0 90: istore 27 92: iconst_1 93: istore 28 95: iconst_2 96: istore 29 98: iconst_3 99: istore 30 101: iconst_4 102: istore 31 104: iconst_5 105: istore 32 107: bipush 6 109: istore 33 111: bipush 12 113: istore 34 115: bipush 127 117: istore 35 119: sipush 128 122: istore 36 124: sipush 32766 127: istore 37 129: sipush 32767 132: istore 38 134: ldc #2 // int 32768 136: istore 39 138: ldc #3 // int 65535 140: istore 40 142: bipush -2 144: istore 41 146: iconst_m1 147: istore 42 149: iconst_0 150: istore 43 152: iconst_1 153: istore 44 155: iconst_2 156: istore 45 158: iconst_3 159: istore 46 161: iconst_4 162: istore 47 164: iconst_5 165: istore 48 167: bipush 6 169: istore 49 171: sipush -129 174: istore 50 176: bipush -128 178: istore 51 180: bipush -127 182: istore 52 184: bipush 127 186: istore 53 188: sipush 128 191: istore 54 193: sipush 255 196: istore 55 198: sipush 256 201: istore 56 203: sipush 257 206: istore 57 208: ldc #4 // int -32769 210: istore 58 212: sipush -32768 215: istore 59 217: sipush 32766 220: istore 60 222: sipush 32767 225: istore 61 227: ldc #2 // int 32768 229: istore 62 231: ldc #5 // int 65534 233: istore 63 235: ldc #3 // int 65535 237: istore 64 239: ldc2_w #6 // long -2l 242: lstore 65 244: ldc2_w #8 // long -1l 247: lstore 67 249: lconst_0 250: lstore 69 252: lconst_1 253: lstore 71 255: ldc2_w #10 // long 2l 258: lstore 73 260: ldc2_w #12 // long 3l 263: lstore 75 265: ldc2_w #14 // long 4l 268: lstore 77 270: ldc2_w #16 // long 5l 273: lstore 79 275: ldc2_w #18 // long 6l 278: lstore 81 280: ldc2_w #20 // long -129l 283: lstore 83 285: ldc2_w #22 // long -128l 288: lstore 85 290: ldc2_w #24 // long -127l 293: lstore 87 295: ldc2_w #26 // long 127l 298: lstore 89 300: ldc2_w #28 // long 128l 303: lstore 91 305: ldc2_w #30 // long 255l 308: lstore 93 310: ldc2_w #32 // long 256l 313: lstore 95 315: ldc2_w #34 // long 257l 318: lstore 97 320: ldc2_w #36 // long -32769l 323: lstore 99 325: ldc2_w #38 // long -32768l 328: lstore 101 330: ldc2_w #40 // long 32766l 333: lstore 103 335: ldc2_w #42 // long 32767l 338: lstore 105 340: ldc2_w #44 // long 32768l 343: lstore 107 345: ldc2_w #46 // long 65534l 348: lstore 109 350: ldc2_w #48 // long 65535l 353: lstore 111 355: ldc2_w #50 // long 165536l 358: lstore 113 360: return","categories":[],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://oatiz.me/tags/JVM/"},{"name":"JAVA","slug":"JAVA","permalink":"https://oatiz.me/tags/JAVA/"}]},{"title":"skywalking5.0部署搭建","slug":"skywalking5-0-0-beta-deployment-build","date":"2018-05-15T10:41:45.000Z","updated":"2018-11-29T11:57:04.674Z","comments":true,"path":"2018/05/15/skywalking5-0-0-beta-deployment-build/","link":"","permalink":"https://oatiz.me/2018/05/15/skywalking5-0-0-beta-deployment-build/","excerpt":"","text":"介绍skywalking官网 skywalking-github 背景相关文章:几种分布式调用链监控组件的实践与比较 我们生产使用的spring cloud体系, \beureka来做服务发现,feign进行通信,默认使用 hystrix做服务熔断. 结合上述相关介绍,我们最终采用skywalking 部署下载点击下载地址,然后选择对应版本进行下载,解压 解压下载后解压,文件目录可以分为三部分: agent: 需要监控的应用的代理 collector: 应用trace信息收集器(被监控应用内数据会被收集起来) webapp: 前端页面展示 结构如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657apache-skywalking-apm-incubating|-- agent| |-- activations| | |-- apm-toolkit-log4j-1.x-activation-5.0.0-beta-SNAPSHOT.jar| | |-- apm-toolkit-log4j-2.x-activation-5.0.0-beta-SNAPSHOT.jar| | |-- apm-toolkit-logback-1.x-activation-5.0.0-beta-SNAPSHOT.jar| | |-- apm-toolkit-opentracing-activation-5.0.0-beta-SNAPSHOT.jar| | `-- apm-toolkit-trace-activation-5.0.0-beta-SNAPSHOT.jar| |-- config| | `-- agent.config| |-- logs| |-- optional-plugins| | `-- apm-spring-annotation-plugin-5.0.0-beta-SNAPSHOT.jar| |-- plugins| | |-- apm-dubbo-plugin-5.0.0-beta-SNAPSHOT.jar| | |-- apm-elastic-job-2.x-plugin-5.0.0-beta-SNAPSHOT.jar| | |-- ......| | `-- tomcat-7.x-8.x-plugin-5.0.0-beta-SNAPSHOT.jar| `-- skywalking-agent.jar|-- bin| |-- collectorService.bat| |-- collectorService.sh| |-- startup.bat| |-- startup.sh| |-- webappService.bat| `-- webappService.sh|-- collector-libs| |-- agent-grpc-define-5.0.0-beta-SNAPSHOT.jar| |-- agent-grpc-provider-5.0.0-beta-SNAPSHOT.jar| |-- agent-jetty-define-5.0.0-beta-SNAPSHOT.jar| |-- ......| `-- zookeeper-3.4.10.jar|-- config| |-- application.yml| |-- component-libraries.yml| `-- log4j2.xml|-- DISCLAIMER|-- LICENSE|-- licenses| |-- LICENSE-annotations.txt| |-- LICENSE-antlr4-runtime.txt| |-- ......| |-- LICENSE-zuul.txt| `-- ui-licenses| |-- LICENSE-add-dom-event-listener| |-- LICENSE-antd| |-- ......| `-- LICENSE-whatwg-fetch|-- logs| |-- collector.log| |-- skywalking-collector-server.log| |-- webapp-console.log| `-- webapp.log|-- NOTICE|-- README.txt`-- webapp `-- skywalking-webapp.jar \b后端部署 修改config/application.yml,将里面所有host改为物理机ip 修改bin/webappService.sh,将collector.ribbon.listOfServers=127.0.0.1:10800,改为config/application.yml里面naming.jetty.host与port 执行bin/startup.sh 需要注意的是,skywalking数据采用elasticsearch 存储.需要部署es,并且修改es的配置文件 elasticsearch.yml,将对应配置改为\b以下配置: 12network.host: 0.0.0.0thread_pool.bulk.queue_size: 1000 agent部署 复制skywalking-agent到任意目录 配置agent/config/agent.config文件 将collector.servers填写为collector配置文件(config/application.yml)中naming/jetty/ip:port 添加参数 在jvm启动参数添加:-javaagent:/path/to/skywalking-agent/skywalking-agent.jar 假设我们已经将skywalking-agent放到/opt/skywalking/目录下,那么我们的启动命令应该写为: java -javaagent:/opt/skywalking/agent/skywalking-agent.jar -Dskywalking.agent.application_code=gateway -jar gateway.jar 配置除了通过/config/agent.config文件外,可以通过环境变量和VM参数(-D)来进行设置 其他因为现有版本5.0.0-alpha有bug,所以需要使用新发布的5.0.0-beta版,所以需要编译对应版本源码 拉取skywalking对应版本代码 git clone https://github.com/apache/incubator-skywalking.git git checkout v5.0.0-beta 拉取子模块 git submodule init git submodule update 修改npm源 打开apm-webapp/pom.xml,搜索frontend-maven-plugin 将install --registry=https://registry.npmjs.org/ 替换为 install --registry=https://registry.npm.taobao.org/ 编译 mvn clean package -DskipTests 打包成功后对应的skywalking存放在apm-dist/target目录下,根据上面的部署步骤使用 注意事项 \bagent中的collector.ip需要与collector 中配置文件中的相同(agent与collector在不同机器时,注意将ip改为对应机器的ip) 部署agent,collector机器的系统时区必须一致(\b不同时dashboard中查看不到数据) 编译时替换npm源 参考链接skywalking-中文文档\b","categories":[],"tags":[{"name":"apm","slug":"apm","permalink":"https://oatiz.me/tags/apm/"},{"name":"skywalking","slug":"skywalking","permalink":"https://oatiz.me/tags/skywalking/"}]},{"title":"hexo mermaid","slug":"mermaid-test","date":"2017-12-04T16:25:06.000Z","updated":"2018-11-29T11:57:04.674Z","comments":true,"path":"2017/12/04/mermaid-test/","link":"","permalink":"https://oatiz.me/2017/12/04/mermaid-test/","excerpt":"","text":"mermaidflowchartgraph TD A-->B; A-->C; B-->D; C-->D; sequencesequenceDiagram participant Alice participant Bob Alice->>John: Hello John, how are you? loop Healthcheck John->>John: Fight against hypochondria end Note right of John: Rational thoughts prevail... John-->>Alice: Great! John->>Bob: How about you? Bob-->>John: Jolly good! ganttgantt dateFormat YYYY-MM-DD title Adding GANTT diagram to mermaid section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d git graphgitGraph: options { \"nodeSpacing\": 150, \"nodeRadius\": 10 } end commit branch newbranch checkout newbranch commit commit checkout master commit commit merge newbranch code1echo \"HelloWorld\" 12345678910@requires_authorizationdef somefunc(param1='', param2=0): r'''A docstring''' # interesting if param1 &gt; param2: print 'Gre\\'ater' return (param2 - param1 + 1) or Noneclass SomeClass: pass","categories":[],"tags":[{"name":"mermaid","slug":"mermaid","permalink":"https://oatiz.me/tags/mermaid/"}]},{"title":"GC学习笔记:GC标记-清除算法(三)","slug":"GC-notes-3-GC-mark-clear-algorithm","date":"2017-11-26T00:17:52.000Z","updated":"2018-11-29T11:57:04.674Z","comments":true,"path":"2017/11/26/GC-notes-3-GC-mark-clear-algorithm/","link":"","permalink":"https://oatiz.me/2017/11/26/GC-notes-3-GC-mark-clear-algorithm/","excerpt":"","text":"GC标记-清除算法标记阶段清除阶段分配合并优点实现简单与保守式GC兼容缺点碎片化分配速度与写时复制技术不兼容多个空闲链表BiBOP算法位图标记优点与写时复制技术兼容清除操作更高效延迟清除法","categories":[],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://oatiz.me/tags/JVM/"},{"name":"GC","slug":"GC","permalink":"https://oatiz.me/tags/GC/"},{"name":"DASS","slug":"DASS","permalink":"https://oatiz.me/tags/DASS/"}]},{"title":"GC学习笔记:GC相关知识(二)","slug":"GC-notes-2-GC-related-knowledge","date":"2017-11-26T00:16:23.000Z","updated":"2018-11-29T11:57:04.674Z","comments":true,"path":"2017/11/26/GC-notes-2-GC-related-knowledge/","link":"","permalink":"https://oatiz.me/2017/11/26/GC-notes-2-GC-related-knowledge/","excerpt":"","text":"GC中基本概念对象/头/域对象\b在GC里,对象表示”通过应用程序利用的数据的集合”。对象配置在内存空间中,GC会根据情况将配置好的对象进行移动或销毁操作。因此,对象是GC的基本单位。对象由“头(header)”与“域(field)”组成 头将对象中保存对象本身信息的部分称为“头”,主要包括以下信息: GC运行所需信息(预先存有) 对象的大小 对象的种类 域把对象使用者在对象中可访问的部分称为“域”,域中的数据类型大致分为2种: 指针\b指向内存空间中某块区域的值 非指针\b编程中直接使用值本身 mutatormutator有改变某物的意思,即改变GC对象间的引用关系。它的实体即为“应用程序”,它进行的实际操作分为2种: 生成对象 更新指针 mutator在进行这些操作是,会为应用程序的用户进行一些处理,随着这些处理的推进,对象间的引用关系随之也会发生”改变”,伴随着这些变化会产生垃圾,而负责\b会后这些就是GC 堆堆是用于存放对象的内存空间,在java堆的实现是一种特殊的树型数据结构 活动对象/非活动对象在已分配到堆中的对象,那些能通过\b程序引用的对象称为”活动对象”,反之,不能通过引用的对象称为”非活动对象”,也就是GC需要回收掉的部分 分配分配(allocation)指的是在内存空间分配对象。当\b堆被活动对象占满,运行GC也无法配置可用空间时,有以下两种选择: 销毁所有计算结果,输出错误信息 扩大堆,分配可用空间 分块分块(chunk)在GC世界里指的是为利用对象而事先准备出来的空间。初始情况下,堆被一个大的分块占据,然后根据mutator的要求把这个分块分割成合适的大小,作为(活动)对象使用。活动对象不久会转化为垃圾回收,此时这部分被回收的内存空间再次分为分块,为下次被利用做准备。周而复始… graph LR A[分块] --> B(活动对象) B --> C{非活动对象} C -->A 根根是指向对象的指针的“起点部分”。 在Java中,可作为根的主要在全局性的引用(例如常量或类静态属性)与执行上下文(例如栈帧中的本地变量表)中。 评价标准评价GC算法性能时,采用以下4个标准: 吞吐量吞吐量指的是单位时间内的处理能力,大概为\bHEAP_SIZE／(GC TIME) 最大暂停时间因执行GC而暂停执行mutator的最长时间, 如mutator执行过程中,共GC了3次,分别耗时1s,5s,3s那么最大暂停时间为5s 堆使用效率 访问的局限性具有引用关系的对象之间通常很可能存在连续访问的情况称为“访问的局限性”。一般会把数据存放到内存中,当cpu访问数据时,仅把要使用的数据从内存中读取到缓存。与此同时,我们还将它附件的所有数据都读取到缓存中\b,从而压缩读取数据所需要的时间。考虑到访问的局限性,把具有引用关系的对象安排到堆中相近的位置,就能提高在缓存中读取到想利用数据的概率。","categories":[],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://oatiz.me/tags/JVM/"},{"name":"GC","slug":"GC","permalink":"https://oatiz.me/tags/GC/"},{"name":"DASS","slug":"DASS","permalink":"https://oatiz.me/tags/DASS/"}]},{"title":"GC学习笔记:GC定义及历史(一)","slug":"GC-notes-1-GC-history","date":"2017-11-25T23:11:14.000Z","updated":"2018-11-29T11:57:04.674Z","comments":true,"path":"2017/11/25/GC-notes-1-GC-history/","link":"","permalink":"https://oatiz.me/2017/11/25/GC-notes-1-GC-history/","excerpt":"","text":"前言\b\b 现实开发中,业务开发人员其实很少接触到GC相关的工作,本人接触GC纯粹是因为好奇和R大的早期博文与一些论坛的回答。断断续续的接触一些碎片化的知识,\b借此将其写下来作为自己学习的一个论证吧。 此系列是阅读中村成洋与相川光著的垃圾回收的算法与实现的笔记。\b 定义GC是Garbage Collection的缩写,也就是“垃圾回收”。顾名思义,程序的垃圾回收就是把程序不用的内存空间回收。 \b\b做的事情 找到内存空间的垃圾 回收垃圾,让空间再次得以利用 \bGC的好处没有GC的\b世界里,由程序员自己手动进行内存管理,这势必非常地麻烦。可能会发生如下问题: 忘记释放内存空间会发生内存泄漏问题 \b释放空间时,忘记初始化指向释放对象的内存空间指针时\b,会发生悬垂指针问题 错误的释放了正在使用中的内存空间,会使程序发生错误 所以在现在的高级语言中都有GC,避免了程序员手动释放内存的麻烦和可能会出现的安全问题 GC的历史 1959: D. Edwards实现了GC 1960: John McCarthy发布了初代GC算法即标记-清除算法 1960: George E. Collins发布了引用计数算法 1963: Marvin L. Minsky发布了复制算法 1996: 首次出版了Garbage Collection一书","categories":[],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://oatiz.me/tags/JVM/"},{"name":"GC","slug":"GC","permalink":"https://oatiz.me/tags/GC/"}]},{"title":"莫枢的JVM分享笔记","slug":"rednaxelafx_share","date":"2017-07-28T16:28:04.000Z","updated":"2018-11-29T11:57:04.674Z","comments":true,"path":"2017/07/28/rednaxelafx_share/","link":"","permalink":"https://oatiz.me/2017/07/28/rednaxelafx_share/","excerpt":"","text":"前言这篇文章是2010年R大做的一次jvm分享 语言处理器的基本结构语言处理器的种类 编译器 gcc, javac 解释器 Ruby,Pythond等一些实现 IDE Eclipse,NetBeans等 代码分析器 FindBugs等 反编译器 JD,Jad, Reflector.NET等 编译器graph LR source[源代码] --> lexicalAnalyzer[词法分析器] lexicalAnalyzer --> tokens[TOKEN流] tokens1[TOKEN流] --> parser[语法分析器] parser --> ast[语法树/抽象语法树] ast1[语法树/抽象语法树] --> semanticAnalyzer[语义分析器] semanticAnalyzer --> annotationAst[注解抽象语法树] annotationAst1[注解抽象语法树] --> intermediateCodeGen[中间代码生成器] intermediateCodeGen --> intermediateCode[中间代码] intermediateCode1[中间代码] --> independentOptimizingMachines[机器无关优化] independentOptimizingMachines --> intermediateCode2[中间代码] intermediateCode3[中间代码] --> machineRelatedOptimization[机器相关优化] machineRelatedOptimization --> intermediateCode4[中间代码] intermediateCode5[中间代码] --> registerAllocator[寄存器分配器] registerAllocator --> intermediateCode6[中间代码] intermediateCode7[中间代码] --> targetCodeGen[目标代码生成器] targetCodeGen --> target[目标代码] style source fill:#EDB784 style tokens fill:#EDB784 style tokens1 fill:#EDB784 style ast fill:#EDB784 style ast1 fill:#EDB784 style annotationAst fill:#EDB784 style annotationAst1 fill:#EDB784 style intermediateCode fill:#EDB784 style intermediateCode1 fill:#EDB784 style intermediateCode2 fill:#EDB784 style intermediateCode2 fill:#EDB784 style intermediateCode3 fill:#EDB784 style intermediateCode4 fill:#EDB784 style intermediateCode5 fill:#EDB784 style intermediateCode6 fill:#EDB784 style intermediateCode7 fill:#EDB784 style target fill:#EDB784 style lexicalAnalyzer fill:#DAF7A6 style parser fill:#DAF7A6 style semanticAnalyzer fill:#DAF7A6 style intermediateCodeGen fill:#DAF7A6 style independentOptimizingMachines fill:#DAF7A6 style machineRelatedOptimization fill:#DAF7A6 style registerAllocator fill:#DAF7A6 style targetCodeGen fill:#DAF7A6 Java语言与平台Java Conceptual DiagramJDK&nbsp;JavaLanguageJavaLanguage&nbsp;&nbsp;Tools &amp;Tool APIsjavajavacjavadocjarjavapjdepsScriptingSecurityMonitoringJConsoleVisualVMJMCJFRJPDAJVM TIIDLRMIJavaDBDeploymentInternationalizationWebServicesTroubleshootingJREDeploymentJava WebStartApplet / Java Plug-inUser InterfaceToolkitsJavaFXSwingJava 2DAWTAccessibilityDrag andDropInput MethodsImageI/OPrintServiceSoundJava SEAPIIntegrationLibrariesIDLJDBCJNDIRMIRMI-IIOPScriptingCompact ProfilesOtherBaseLibrariesBeansSecuritySerializationExtension MechanismJMXXML JAXPNetworkingOverride MechanismJNIDate and TimeInput/OutputInternationalizationlang and utilBase Librarieslang and utilMathCollectionsRefObjectsRegular ExpressionsLoggingManagementInstrumentationConcurrency UtilitiesReflectionVersioningPreferences APIJARZipJava VirtualMachineJava HotSpot Clientand Server VM&nbsp;&nbsp; Java源码级编译器(javac)Class文件虚拟机与JVMHotSpot VMHotSpot VM的运行时支持HotSpot与解释器HotSpot与JIT编译器HotSpot VM与JSR 292","categories":[],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://oatiz.me/tags/JVM/"},{"name":"JAVA","slug":"JAVA","permalink":"https://oatiz.me/tags/JAVA/"}]},{"title":"建站前言","slug":"preface","date":"2017-07-28T00:24:25.000Z","updated":"2018-11-29T11:57:04.674Z","comments":true,"path":"2017/07/28/preface/","link":"","permalink":"https://oatiz.me/2017/07/28/preface/","excerpt":"","text":"组件hexoyilia tips 评论采用Disqus,需翻墙后才可留言 碎碎念其实在建站之前已经有过一个blog了,但是没有保持下去。原因个人觉得别人已经写好了,没必要重复的去抄别人:)。现在重新得去编写,其实觉得现在的生活乏味无趣,不如找个事情来充实自己。再者自己基础知识很不好,借着这个名头坚持下。 说到学习笔记,个人会通过看书,读别人的博客,实践来验证自己所需掌握的知识点。在此站,会将各个出处标识清楚。 碎碎念结束,愿自己坚持下去。 祝好:)","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://oatiz.me/tags/随笔/"}]}]}